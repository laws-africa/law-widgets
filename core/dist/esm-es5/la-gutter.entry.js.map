{"version":3,"names":["GutterLayout","root","this","buffer","tops","WeakMap","anchors","prototype","layout","items","updateAnchorsAndItems","updateTops","sortItems","activeItem","find","x","active","ix","indexOf","anchor","get","top","style","concat","layoutUpwards","layoutDownwards","clientHeight","__spreadArray","sort","compareItems","bind","a","b","anchorA","anchorB","topA","topB","start","watermark","i","item","length","Math","max","_i","items_1","getItemAnchor","set","display","HTMLElement","contains","querySelector","items_2","has","calculateTop","element","el","offsetTop","offsetParent","gutterCss","LaGutterStyle0","Gutter","debounceDelay","class_1","componentWillLoad","akomaNtosoElement","getAkomaNtosoElement","akomaNtoso","queueLayout","debounce","layoutItems","mutationObserver","MutationObserver","observe","childList","componentDidLoad","setupLayout","disconnectedCallback","disconnect","resizeObserver","itemChanged","event","target","setOtherItemsInactive","clicked","closest","Array","from","forEach","window","ResizeObserver","layoutComplete","emit","activateNextItem","getVisibleItems","activeItemIndex","findIndex","nextActiveItem","activatePrevItem","querySelectorAll","filter"],"sources":["src/components/gutter/layout.ts","src/components/gutter/gutter.scss?tag=la-gutter","src/components/gutter/gutter.tsx"],"sourcesContent":["/**\n * Helper class to determine the vertical layout of a collection of gutter content elements, such that they are aligned\n * vertically with their anchor elements, but don't overlap each other.\n */\nexport class GutterLayout {\n  protected root: HTMLElement;\n  protected buffer: number;\n  protected tops: WeakMap<HTMLElement, number>;\n  protected anchors: WeakMap<HTMLElement, HTMLElement>;\n\n  /**\n   * @param root root element for determining heights against. This MUST have a position style attribute,\n   *             such as position: relative;\n   */\n  constructor(root: HTMLElement) {\n    this.root = root;\n    // vertical buffer between elements\n    this.buffer = 10;\n    this.tops = new WeakMap();\n    this.anchors = new WeakMap();\n  }\n\n  layout(items: HTMLLaGutterItemElement[]) {\n    this.updateAnchorsAndItems(items);\n\n    // pre-calculate tops\n    this.updateTops(items);\n\n    // sort items by ascending anchorElement top\n    items = this.sortItems(items);\n\n    // find the first item that is active\n    const activeItem: HTMLLaGutterItemElement | undefined = items.find((x) => x.active);\n\n    if (activeItem) {\n      const ix = items.indexOf(activeItem);\n      if (ix > -1) {\n        // layout the primary item first\n        const anchor: HTMLElement | undefined = this.anchors.get(activeItem);\n        if (anchor) {\n          const top = this.tops.get(anchor);\n          if (top) {\n            activeItem.style.top = `${top}px`;\n            // layout the ones going upwards from here\n            this.layoutUpwards(items, ix - 1, top - this.buffer);\n            // layout the ones going downwards from here\n            this.layoutDownwards(items, ix + 1, top + activeItem.clientHeight + this.buffer);\n            return;\n          }\n        }\n      }\n    }\n\n    // nothing is primary, go top downwards\n    this.layoutDownwards(items, 0, 0);\n  }\n\n  sortItems(items: HTMLLaGutterItemElement[]) {\n    return [...items].sort(this.compareItems.bind(this));\n  }\n\n  /**\n   * Comparator that sorts items be ascending top value.\n   */\n  compareItems(a: HTMLLaGutterItemElement, b: HTMLLaGutterItemElement): number {\n    const anchorA: HTMLElement | undefined = this.anchors.get(a);\n    const anchorB: HTMLElement | undefined = this.anchors.get(b);\n\n    if (anchorA) {\n      if (anchorB) {\n        const topA: number | undefined = this.tops.get(anchorA);\n        const topB: number | undefined = this.tops.get(anchorB);\n\n        if (topA) {\n          if (topB) {\n            return topA - topB;\n          } else {\n            // a has an top, b doesn't, so a comes after b\n            return 1;\n          }\n        } else {\n          // a has no top, best if b comes after a\n          return -1;\n        }\n      } else {\n        // a has an anchor, b doesn't, so a comes after b\n        return 1;\n      }\n    } else {\n      // a has no anchor, best if b comes after a\n      return -1;\n    }\n  }\n\n  layoutUpwards(items: HTMLLaGutterItemElement[], start: number, watermark: number) {\n    // layout the items from index start, going bottom to top\n    for (let i = start; i >= 0; i--) {\n      const item = items[i];\n      const anchor: HTMLElement | undefined = this.anchors.get(item);\n      if (anchor) {\n        let top = this.tops.get(anchor);\n        if (top) {\n          if (top + item.clientHeight >= watermark) {\n            top = watermark - item.clientHeight;\n          }\n          item.style.top = `${top}px`;\n          watermark = top - this.buffer;\n        }\n      }\n    }\n  }\n\n  layoutDownwards(items: HTMLLaGutterItemElement[], start: number, watermark: number) {\n    // layout the items from index start, going top to bottom\n    for (let i = start; i < items.length; i++) {\n      const item = items[i];\n      const anchor: HTMLElement | undefined = this.anchors.get(item);\n      if (anchor) {\n        let top = this.tops.get(anchor);\n        if (top) {\n          top = Math.max(watermark, top);\n          item.style.top = `${top}px`;\n          watermark = top + item.clientHeight + this.buffer;\n        }\n      }\n    }\n  }\n\n  updateAnchorsAndItems(items: HTMLLaGutterItemElement[]) {\n    this.anchors = new WeakMap();\n\n    for (const item of items) {\n      const anchor: HTMLElement | null = this.getItemAnchor(item);\n      if (anchor) {\n        this.anchors.set(item, anchor);\n      }\n      item.style.display = anchor ? '' : 'none';\n    }\n  }\n\n  getItemAnchor(item: HTMLLaGutterItemElement): HTMLElement | null {\n    if (item.anchor) {\n      if (item.anchor instanceof HTMLElement) {\n        return this.root.contains(item.anchor) ? item.anchor : null;\n      } else {\n        return this.root.querySelector(item.anchor);\n      }\n    }\n    return null;\n  }\n\n  updateTops(items: HTMLLaGutterItemElement[]) {\n    this.tops = new WeakMap();\n\n    for (const item of items) {\n      const anchor: HTMLElement | undefined = this.anchors.get(item);\n      if (anchor && !this.tops.has(anchor)) {\n        this.tops.set(anchor, this.calculateTop(anchor));\n      }\n    }\n  }\n\n  /**\n   * Find the top of an element, relative to this.root.\n   * @param element\n   * @returns {number}\n   */\n  calculateTop(element: HTMLElement) {\n    let top = 0;\n    let el: HTMLElement | null = element;\n\n    while (el && el !== this.root) {\n      top += el.offsetTop;\n      el = el.offsetParent as HTMLElement;\n    }\n\n    return top;\n  }\n}\n","$la-gutter-padding: 0.5rem;\n\n.la-akoma-ntoso-with-gutter {\n  display: flex;\n  flex-direction: row;\n\n  &> la-akoma-ntoso {\n    flex: 80%;\n    max-width: 80%;\n    position: relative;\n    padding-right: $la-gutter-padding;\n  }\n\n  &> la-gutter {\n    flex: 20%;\n    max-width: 20%;\n    position: relative;\n    overflow-y: hidden;\n\n    background-color: rgba(0, 0, 0, 0.05);\n    padding-left: $la-gutter-padding;\n    padding-right: $la-gutter-padding;\n  }\n}\n\nla-gutter > la-gutter-item {\n  position: absolute;\n  left: 2 * $la-gutter-padding;\n  width: calc(100% - 3 * $la-gutter-padding);\n  transition: top ease-out 100ms, left ease-out 100ms;\n  z-index: 2;\n\n  &[active] {\n    left: $la-gutter-padding;\n    z-index: 3;\n  }\n}\n","import type { EventEmitter } from '@stencil/core';\nimport { Component, Element, Prop, Listen, Method, Event } from '@stencil/core';\nimport debounce from 'lodash/debounce';\n\nimport { getAkomaNtosoElement } from '../../utils/linking';\n\nimport { GutterLayout } from './layout';\n\n@Component({\n  tag: 'la-gutter',\n  styleUrl: 'gutter.scss',\n})\nexport class Gutter {\n  // The akn content element being decorated\n  protected akomaNtosoElement?: HTMLElement | null;\n\n  protected layout?: GutterLayout;\n  protected resizeObserver?: ResizeObserver;\n  protected mutationObserver?: MutationObserver;\n\n  // Delay in msecs to debounce updates\n  protected debounceDelay = 100;\n  protected queueLayout: any;\n\n  /**\n   * CSS selector or HTMLElement for the la-akoma-ntoso element that will be decorated. Defaults\n   * to the containing la-akoma-ntoso element, if any, otherwise the first\n   * `la-akoma-ntoso` element on the page.\n   */\n  // TODO: should  we be watching this? What if it changes?\n  @Prop() akomaNtoso?: string | HTMLElement;\n\n  @Element() el!: HTMLElement;\n\n  componentWillLoad() {\n    // TODO: watch for changes to the akn content?\n    this.akomaNtosoElement = getAkomaNtosoElement(this.el, this.akomaNtoso);\n\n    // setup a debounced function to trigger a layout run.\n    this.queueLayout = debounce(this.layoutItems.bind(this), this.debounceDelay);\n\n    // re-run layout when child elements change\n    this.mutationObserver = new MutationObserver(this.queueLayout);\n    this.mutationObserver.observe(this.el, { childList: true });\n  }\n\n  componentDidLoad() {\n    this.setupLayout();\n    this.layoutItems();\n  }\n\n  disconnectedCallback() {\n    if (this.mutationObserver) {\n      this.mutationObserver.disconnect();\n    }\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n  }\n\n  @Listen('laItemChanged')\n  itemChanged(event: CustomEvent) {\n    const target: HTMLLaGutterItemElement | null = event.target as HTMLLaGutterItemElement;\n    if (target?.active) {\n      // set all other items inactive. if there was a previously active item, this change will\n      // trigger a new event, but the debounce will prevent an unnecessary layout.\n      this.setOtherItemsInactive(target);\n    }\n    this.queueLayout();\n  }\n\n  @Listen('click')\n  clicked(event: MouseEvent) {\n    // a click in the gutter, outside of an item, deactivates all items\n    const target: HTMLElement | null = event.target as HTMLElement;\n    if (target && !target.closest('la-gutter-item')) {\n      Array.from(this.items()).forEach((item) => {\n        item.active = false;\n      });\n    }\n  }\n\n  /**\n   * Event emitted when `this.layout` has finished.\n   */\n  @Event({\n    eventName: 'layoutComplete',\n    composed: true,\n    cancelable: true,\n  })\n  layoutComplete!: EventEmitter<void>;\n\n  /**\n   * Ensure all items except this one are set as inactive.\n   */\n  setOtherItemsInactive(activeItem: HTMLLaGutterItemElement) {\n    Array.from(this.items()).forEach((item) => {\n      if (item != activeItem) {\n        item.active = false;\n      }\n    });\n  }\n\n  setupLayout() {\n    if (this.akomaNtosoElement) {\n      this.layout = new GutterLayout(this.akomaNtosoElement);\n\n      if (window.ResizeObserver) {\n        if (this.resizeObserver) this.resizeObserver.disconnect();\n\n        // add observer to re-layout when the containing document changes size, which implies marker positions will change\n        this.resizeObserver = new ResizeObserver(this.queueLayout);\n        this.resizeObserver.observe(this.akomaNtosoElement);\n      }\n    }\n  }\n\n  /**\n   * Layout the gutter items.\n   */\n  @Method()\n  async layoutItems() {\n    if (this.layout) {\n      // @ts-ignore\n      this.layout.layout([...this.items()]);\n      this.layoutComplete.emit();\n    }\n  }\n\n  /**\n   * Activates the item logically after the currently active item. The activated item's `active` property will be set to\n   * true. Returns the activated item. Or returns null if there are no items. If there is no item currently\n   * active, the top-most item is activated. If the currently active item is the bottom-most item in the gutter,\n   * then the top-most item will be activated. If there is one item in the gutter that is not active, then that item will be activated.\n   */\n  @Method()\n  async activateNextItem() {\n    const items: HTMLLaGutterItemElement[] = this.layout ? this.layout.sortItems(this.getVisibleItems()) : [];\n\n    if (items.length === 1) {\n      items[0].active = true;\n      return items[0];\n    } else if (items.length > 1) {\n      const activeItemIndex = items.findIndex((item) => item.active);\n      const nextActiveItem =\n        activeItemIndex === -1 || activeItemIndex === items.length - 1 ? items[0] : items[activeItemIndex + 1];\n      nextActiveItem.active = true;\n      return nextActiveItem;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Activates the item logically before the currently active item. The activated item's `active` property will be set to\n   * true. Returns the activated item. Or returns null if there are no items. If there is no item currently\n   * active, the bottom-most item is activated. If the currently active item is the top-most item in the gutter,\n   * then the bottom-most item will be activated. If there is one item in the gutter that is not active, then that item will be activated.\n   */\n  @Method()\n  async activatePrevItem() {\n    const items: HTMLLaGutterItemElement[] = this.layout ? this.layout.sortItems(this.getVisibleItems()) : [];\n\n    if (items.length === 1) {\n      items[0].active = true;\n      return items[0];\n    } else if (items.length > 1) {\n      const activeItemIndex = items.findIndex((item) => item.active);\n      const nextActiveItem =\n        activeItemIndex === -1 || activeItemIndex === 0 ? items[items.length - 1] : items[activeItemIndex - 1];\n      nextActiveItem.active = true;\n      return nextActiveItem;\n    } else {\n      return null;\n    }\n  }\n\n  items(): NodeListOf<HTMLLaGutterItemElement> {\n    return this.el.querySelectorAll('la-gutter-item');\n  }\n\n  getVisibleItems(): HTMLLaGutterItemElement[] {\n    // @ts-ignore\n    return [...this.items()].filter((i) => i.style.display !== 'none');\n  }\n}\n"],"mappings":"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","ignoreList":[]}