{"file":"la-gutter.js","mappings":";;;;;;;AAAA;;;;MAIa,YAAY;;;;;IAUvB,YAAY,IAAiB;QAC3B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;;QAEjB,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QACjB,IAAI,CAAC,IAAI,GAAG,IAAI,OAAO,EAAE,CAAC;QAC1B,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,EAAE,CAAC;KAC9B;IAED,MAAM,CAAC,KAAgC;QACrC,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;;QAGlC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;;QAGvB,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;;QAG9B,MAAM,UAAU,GAAwC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;QAEpF,IAAI,UAAU,EAAE;YACd,MAAM,EAAE,GAAG,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YACrC,IAAI,EAAE,GAAG,CAAC,CAAC,EAAE;;gBAEX,MAAM,MAAM,GAA4B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;gBACrE,IAAI,MAAM,EAAE;oBACV,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;oBAClC,IAAI,GAAG,EAAE;wBACP,UAAU,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC;;wBAElC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,EAAE,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC;;wBAErD,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,EAAE,GAAG,CAAC,EAAE,GAAG,GAAG,UAAU,CAAC,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC;wBACjF,OAAO;qBACR;iBACF;aACF;SACF;;QAGD,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;KACnC;IAED,SAAS,CAAC,KAAgC;QACxC,OAAO,CAAC,GAAG,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;KACtD;;;;IAKD,YAAY,CAAC,CAA0B,EAAE,CAA0B;QACjE,MAAM,OAAO,GAA4B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAC7D,MAAM,OAAO,GAA4B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAE7D,IAAI,OAAO,EAAE;YACX,IAAI,OAAO,EAAE;gBACX,MAAM,IAAI,GAAuB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;gBACxD,MAAM,IAAI,GAAuB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;gBAExD,IAAI,IAAI,EAAE;oBACR,IAAI,IAAI,EAAE;wBACR,OAAO,IAAI,GAAG,IAAI,CAAC;qBACpB;yBAAM;;wBAEL,OAAO,CAAC,CAAC;qBACV;iBACF;qBAAM;;oBAEL,OAAO,CAAC,CAAC,CAAC;iBACX;aACF;iBAAM;;gBAEL,OAAO,CAAC,CAAC;aACV;SACF;aAAM;;YAEL,OAAO,CAAC,CAAC,CAAC;SACX;KACF;IAED,aAAa,CAAC,KAAgC,EAAE,KAAa,EAAE,SAAiB;;QAE9E,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YAC/B,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,MAAM,MAAM,GAA4B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAC/D,IAAI,MAAM,EAAE;gBACV,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBAChC,IAAI,GAAG,EAAE;oBACP,IAAI,GAAG,GAAG,IAAI,CAAC,YAAY,IAAI,SAAS,EAAE;wBACxC,GAAG,GAAG,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC;qBACrC;oBACD,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC;oBAC5B,SAAS,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;iBAC/B;aACF;SACF;KACF;IAED,eAAe,CAAC,KAAgC,EAAE,KAAa,EAAE,SAAiB;;QAEhF,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACzC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,MAAM,MAAM,GAA4B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAC/D,IAAI,MAAM,EAAE;gBACV,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBAChC,IAAI,GAAG,EAAE;oBACP,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;oBAC/B,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC;oBAC5B,SAAS,GAAG,GAAG,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC;iBACnD;aACF;SACF;KACF;IAED,qBAAqB,CAAC,KAAgC;QACpD,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,EAAE,CAAC;QAE7B,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YACxB,MAAM,MAAM,GAAuB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YAC5D,IAAI,MAAM,EAAE;gBACV,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;aAChC;YACD,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,MAAM,GAAG,EAAE,GAAG,MAAM,CAAC;SAC3C;KACF;IAED,aAAa,CAAC,IAA6B;QACzC,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,IAAI,IAAI,CAAC,MAAM,YAAY,WAAW,EAAE;gBACtC,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;aAC7D;iBAAM;gBACL,OAAO,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aAC7C;SACF;QACD,OAAO,IAAI,CAAC;KACb;IAED,UAAU,CAAC,KAAgC;QACzC,IAAI,CAAC,IAAI,GAAG,IAAI,OAAO,EAAE,CAAC;QAE1B,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YACxB,MAAM,MAAM,GAA4B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAC/D,IAAI,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;gBACpC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC;aAClD;SACF;KACF;;;;;;IAOD,YAAY,CAAC,OAAoB;QAC/B,IAAI,GAAG,GAAG,CAAC,CAAC;QACZ,IAAI,EAAE,GAAuB,OAAO,CAAC;QAErC,OAAO,EAAE,IAAI,EAAE,KAAK,IAAI,CAAC,IAAI,EAAE;YAC7B,GAAG,IAAI,EAAE,CAAC,SAAS,CAAC;YACpB,EAAE,GAAG,EAAE,CAAC,YAA2B,CAAC;SACrC;QAED,OAAO,GAAG,CAAC;KACZ;;;ACjLH,MAAM,SAAS,GAAG,ypBAAypB,CAAC;AAC5qB,uBAAe,SAAS;;MCWX,MAAM;;;;;;QASP,kBAAa,GAAG,GAAG,CAAC;;;IAa9B,iBAAiB;;QAEf,IAAI,CAAC,iBAAiB,GAAG,oBAAoB,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;;QAGxE,IAAI,CAAC,WAAW,GAAGA,UAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;;QAG7E,IAAI,CAAC,gBAAgB,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC/D,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;KAC7D;IAED,gBAAgB;QACd,IAAI,CAAC,WAAW,EAAE,CAAC;QACnB,IAAI,CAAC,WAAW,EAAE,CAAC;KACpB;IAED,oBAAoB;QAClB,IAAI,IAAI,CAAC,gBAAgB,EAAE;YACzB,IAAI,CAAC,gBAAgB,CAAC,UAAU,EAAE,CAAC;SACpC;QAED,IAAI,IAAI,CAAC,cAAc,EAAE;YACvB,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,CAAC;SAClC;KACF;IAGD,WAAW,CAAC,KAAkB;QAC5B,MAAM,MAAM,GAAmC,KAAK,CAAC,MAAiC,CAAC;QACvF,IAAI,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,MAAM,EAAE;;;YAGlB,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;SACpC;QACD,IAAI,CAAC,WAAW,EAAE,CAAC;KACpB;IAGD,OAAO,CAAC,KAAiB;;QAEvB,MAAM,MAAM,GAAuB,KAAK,CAAC,MAAqB,CAAC;QAC/D,IAAI,MAAM,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,gBAAgB,CAAC,EAAE;YAC/C,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI;gBACpC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;aACrB,CAAC,CAAC;SACJ;KACF;;;;IAeD,qBAAqB,CAAC,UAAmC;QACvD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI;YACpC,IAAI,IAAI,IAAI,UAAU,EAAE;gBACtB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;aACrB;SACF,CAAC,CAAC;KACJ;IAED,WAAW;QACT,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC1B,IAAI,CAAC,MAAM,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;YAEvD,IAAI,MAAM,CAAC,cAAc,EAAE;gBACzB,IAAI,IAAI,CAAC,cAAc;oBAAE,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,CAAC;;gBAG1D,IAAI,CAAC,cAAc,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBAC3D,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;aACrD;SACF;KACF;;;;IAMD,MAAM,WAAW;QACf,IAAI,IAAI,CAAC,MAAM,EAAE;;YAEf,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;YACtC,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC;SAC5B;KACF;;;;;;;IASD,MAAM,gBAAgB;QACpB,MAAM,KAAK,GAA8B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,GAAG,EAAE,CAAC;QAE1G,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACtB,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;YACvB,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC;SACjB;aAAM,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YAC3B,MAAM,eAAe,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,CAAC;YAC/D,MAAM,cAAc,GAClB,eAAe,KAAK,CAAC,CAAC,IAAI,eAAe,KAAK,KAAK,CAAC,MAAM,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC;YACzG,cAAc,CAAC,MAAM,GAAG,IAAI,CAAC;YAC7B,OAAO,cAAc,CAAC;SACvB;aAAM;YACL,OAAO,IAAI,CAAC;SACb;KACF;;;;;;;IASD,MAAM,gBAAgB;QACpB,MAAM,KAAK,GAA8B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,GAAG,EAAE,CAAC;QAE1G,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACtB,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;YACvB,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC;SACjB;aAAM,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YAC3B,MAAM,eAAe,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,CAAC;YAC/D,MAAM,cAAc,GAClB,eAAe,KAAK,CAAC,CAAC,IAAI,eAAe,KAAK,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC;YACzG,cAAc,CAAC,MAAM,GAAG,IAAI,CAAC;YAC7B,OAAO,cAAc,CAAC;SACvB;aAAM;YACL,OAAO,IAAI,CAAC;SACb;KACF;IAED,KAAK;QACH,OAAO,IAAI,CAAC,EAAE,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,CAAC;KACnD;IAED,eAAe;;QAEb,OAAO,CAAC,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,OAAO,KAAK,MAAM,CAAC,CAAC;KACpE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","names":["debounce"],"sources":["src/components/gutter/layout.ts","src/components/gutter/gutter.scss?tag=la-gutter","src/components/gutter/gutter.tsx"],"sourcesContent":["/**\n * Helper class to determine the vertical layout of a collection of gutter content elements, such that they are aligned\n * vertically with their anchor elements, but don't overlap each other.\n */\nexport class GutterLayout {\n  protected root: HTMLElement;\n  protected buffer: number;\n  protected tops: WeakMap<HTMLElement, number>;\n  protected anchors: WeakMap<HTMLElement, HTMLElement>;\n\n  /**\n   * @param root root element for determining heights against. This MUST have a position style attribute,\n   *             such as position: relative;\n   */\n  constructor(root: HTMLElement) {\n    this.root = root;\n    // vertical buffer between elements\n    this.buffer = 10;\n    this.tops = new WeakMap();\n    this.anchors = new WeakMap();\n  }\n\n  layout(items: HTMLLaGutterItemElement[]) {\n    this.updateAnchorsAndItems(items);\n\n    // pre-calculate tops\n    this.updateTops(items);\n\n    // sort items by ascending anchorElement top\n    items = this.sortItems(items);\n\n    // find the first item that is active\n    const activeItem: HTMLLaGutterItemElement | undefined = items.find((x) => x.active);\n\n    if (activeItem) {\n      const ix = items.indexOf(activeItem);\n      if (ix > -1) {\n        // layout the primary item first\n        const anchor: HTMLElement | undefined = this.anchors.get(activeItem);\n        if (anchor) {\n          const top = this.tops.get(anchor);\n          if (top) {\n            activeItem.style.top = `${top}px`;\n            // layout the ones going upwards from here\n            this.layoutUpwards(items, ix - 1, top - this.buffer);\n            // layout the ones going downwards from here\n            this.layoutDownwards(items, ix + 1, top + activeItem.clientHeight + this.buffer);\n            return;\n          }\n        }\n      }\n    }\n\n    // nothing is primary, go top downwards\n    this.layoutDownwards(items, 0, 0);\n  }\n\n  sortItems(items: HTMLLaGutterItemElement[]) {\n    return [...items].sort(this.compareItems.bind(this));\n  }\n\n  /**\n   * Comparator that sorts items be ascending top value.\n   */\n  compareItems(a: HTMLLaGutterItemElement, b: HTMLLaGutterItemElement): number {\n    const anchorA: HTMLElement | undefined = this.anchors.get(a);\n    const anchorB: HTMLElement | undefined = this.anchors.get(b);\n\n    if (anchorA) {\n      if (anchorB) {\n        const topA: number | undefined = this.tops.get(anchorA);\n        const topB: number | undefined = this.tops.get(anchorB);\n\n        if (topA) {\n          if (topB) {\n            return topA - topB;\n          } else {\n            // a has an top, b doesn't, so a comes after b\n            return 1;\n          }\n        } else {\n          // a has no top, best if b comes after a\n          return -1;\n        }\n      } else {\n        // a has an anchor, b doesn't, so a comes after b\n        return 1;\n      }\n    } else {\n      // a has no anchor, best if b comes after a\n      return -1;\n    }\n  }\n\n  layoutUpwards(items: HTMLLaGutterItemElement[], start: number, watermark: number) {\n    // layout the items from index start, going bottom to top\n    for (let i = start; i >= 0; i--) {\n      const item = items[i];\n      const anchor: HTMLElement | undefined = this.anchors.get(item);\n      if (anchor) {\n        let top = this.tops.get(anchor);\n        if (top) {\n          if (top + item.clientHeight >= watermark) {\n            top = watermark - item.clientHeight;\n          }\n          item.style.top = `${top}px`;\n          watermark = top - this.buffer;\n        }\n      }\n    }\n  }\n\n  layoutDownwards(items: HTMLLaGutterItemElement[], start: number, watermark: number) {\n    // layout the items from index start, going top to bottom\n    for (let i = start; i < items.length; i++) {\n      const item = items[i];\n      const anchor: HTMLElement | undefined = this.anchors.get(item);\n      if (anchor) {\n        let top = this.tops.get(anchor);\n        if (top) {\n          top = Math.max(watermark, top);\n          item.style.top = `${top}px`;\n          watermark = top + item.clientHeight + this.buffer;\n        }\n      }\n    }\n  }\n\n  updateAnchorsAndItems(items: HTMLLaGutterItemElement[]) {\n    this.anchors = new WeakMap();\n\n    for (const item of items) {\n      const anchor: HTMLElement | null = this.getItemAnchor(item);\n      if (anchor) {\n        this.anchors.set(item, anchor);\n      }\n      item.style.display = anchor ? '' : 'none';\n    }\n  }\n\n  getItemAnchor(item: HTMLLaGutterItemElement): HTMLElement | null {\n    if (item.anchor) {\n      if (item.anchor instanceof HTMLElement) {\n        return this.root.contains(item.anchor) ? item.anchor : null;\n      } else {\n        return this.root.querySelector(item.anchor);\n      }\n    }\n    return null;\n  }\n\n  updateTops(items: HTMLLaGutterItemElement[]) {\n    this.tops = new WeakMap();\n\n    for (const item of items) {\n      const anchor: HTMLElement | undefined = this.anchors.get(item);\n      if (anchor && !this.tops.has(anchor)) {\n        this.tops.set(anchor, this.calculateTop(anchor));\n      }\n    }\n  }\n\n  /**\n   * Find the top of an element, relative to this.root.\n   * @param element\n   * @returns {number}\n   */\n  calculateTop(element: HTMLElement) {\n    let top = 0;\n    let el: HTMLElement | null = element;\n\n    while (el && el !== this.root) {\n      top += el.offsetTop;\n      el = el.offsetParent as HTMLElement;\n    }\n\n    return top;\n  }\n}\n","$la-gutter-padding: 0.5rem;\n\n.la-akoma-ntoso-with-gutter {\n  display: flex;\n  flex-direction: row;\n\n  &> la-akoma-ntoso {\n    flex: 80%;\n    max-width: 80%;\n    position: relative;\n    padding-right: $la-gutter-padding;\n  }\n\n  &> la-gutter {\n    flex: 20%;\n    max-width: 20%;\n    position: relative;\n    overflow-y: hidden;\n\n    background-color: rgba(0, 0, 0, 0.05);\n    padding-left: $la-gutter-padding;\n    padding-right: $la-gutter-padding;\n  }\n}\n\nla-gutter > la-gutter-item {\n  position: absolute;\n  left: 2 * $la-gutter-padding;\n  width: calc(100% - 3 * $la-gutter-padding);\n  transition: top ease-out 100ms, left ease-out 100ms;\n  z-index: 2;\n\n  &[active] {\n    left: $la-gutter-padding;\n    z-index: 3;\n  }\n}\n","import type { EventEmitter } from '@stencil/core';\nimport { Component, Element, Prop, Listen, Method, Event } from '@stencil/core';\nimport debounce from 'lodash/debounce';\n\nimport { getAkomaNtosoElement } from '../../utils/linking';\n\nimport { GutterLayout } from './layout';\n\n@Component({\n  tag: 'la-gutter',\n  styleUrl: 'gutter.scss',\n})\nexport class Gutter {\n  // The akn content element being decorated\n  protected akomaNtosoElement?: HTMLElement | null;\n\n  protected layout?: GutterLayout;\n  protected resizeObserver?: ResizeObserver;\n  protected mutationObserver?: MutationObserver;\n\n  // Delay in msecs to debounce updates\n  protected debounceDelay = 100;\n  protected queueLayout: any;\n\n  /**\n   * CSS selector or HTMLElement for the la-akoma-ntoso element that will be decorated. Defaults\n   * to the containing la-akoma-ntoso element, if any, otherwise the first\n   * `la-akoma-ntoso` element on the page.\n   */\n  // TODO: should  we be watching this? What if it changes?\n  @Prop() akomaNtoso?: string | HTMLElement;\n\n  @Element() el!: HTMLElement;\n\n  componentWillLoad() {\n    // TODO: watch for changes to the akn content?\n    this.akomaNtosoElement = getAkomaNtosoElement(this.el, this.akomaNtoso);\n\n    // setup a debounced function to trigger a layout run.\n    this.queueLayout = debounce(this.layoutItems.bind(this), this.debounceDelay);\n\n    // re-run layout when child elements change\n    this.mutationObserver = new MutationObserver(this.queueLayout);\n    this.mutationObserver.observe(this.el, { childList: true });\n  }\n\n  componentDidLoad() {\n    this.setupLayout();\n    this.layoutItems();\n  }\n\n  disconnectedCallback() {\n    if (this.mutationObserver) {\n      this.mutationObserver.disconnect();\n    }\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n  }\n\n  @Listen('laItemChanged')\n  itemChanged(event: CustomEvent) {\n    const target: HTMLLaGutterItemElement | null = event.target as HTMLLaGutterItemElement;\n    if (target?.active) {\n      // set all other items inactive. if there was a previously active item, this change will\n      // trigger a new event, but the debounce will prevent an unnecessary layout.\n      this.setOtherItemsInactive(target);\n    }\n    this.queueLayout();\n  }\n\n  @Listen('click')\n  clicked(event: MouseEvent) {\n    // a click in the gutter, outside of an item, deactivates all items\n    const target: HTMLElement | null = event.target as HTMLElement;\n    if (target && !target.closest('la-gutter-item')) {\n      Array.from(this.items()).forEach((item) => {\n        item.active = false;\n      });\n    }\n  }\n\n  /**\n   * Event emitted when `this.layout` has finished.\n   */\n  @Event({\n    eventName: 'layoutComplete',\n    composed: true,\n    cancelable: true,\n  })\n  layoutComplete!: EventEmitter<void>;\n\n  /**\n   * Ensure all items except this one are set as inactive.\n   */\n  setOtherItemsInactive(activeItem: HTMLLaGutterItemElement) {\n    Array.from(this.items()).forEach((item) => {\n      if (item != activeItem) {\n        item.active = false;\n      }\n    });\n  }\n\n  setupLayout() {\n    if (this.akomaNtosoElement) {\n      this.layout = new GutterLayout(this.akomaNtosoElement);\n\n      if (window.ResizeObserver) {\n        if (this.resizeObserver) this.resizeObserver.disconnect();\n\n        // add observer to re-layout when the containing document changes size, which implies marker positions will change\n        this.resizeObserver = new ResizeObserver(this.queueLayout);\n        this.resizeObserver.observe(this.akomaNtosoElement);\n      }\n    }\n  }\n\n  /**\n   * Layout the gutter items.\n   */\n  @Method()\n  async layoutItems() {\n    if (this.layout) {\n      // @ts-ignore\n      this.layout.layout([...this.items()]);\n      this.layoutComplete.emit();\n    }\n  }\n\n  /**\n   * Activates the item logically after the currently active item. The activated item's `active` property will be set to\n   * true. Returns the activated item. Or returns null if there are no items. If there is no item currently\n   * active, the top-most item is activated. If the currently active item is the bottom-most item in the gutter,\n   * then the top-most item will be activated. If there is one item in the gutter that is not active, then that item will be activated.\n   */\n  @Method()\n  async activateNextItem() {\n    const items: HTMLLaGutterItemElement[] = this.layout ? this.layout.sortItems(this.getVisibleItems()) : [];\n\n    if (items.length === 1) {\n      items[0].active = true;\n      return items[0];\n    } else if (items.length > 1) {\n      const activeItemIndex = items.findIndex((item) => item.active);\n      const nextActiveItem =\n        activeItemIndex === -1 || activeItemIndex === items.length - 1 ? items[0] : items[activeItemIndex + 1];\n      nextActiveItem.active = true;\n      return nextActiveItem;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Activates the item logically before the currently active item. The activated item's `active` property will be set to\n   * true. Returns the activated item. Or returns null if there are no items. If there is no item currently\n   * active, the bottom-most item is activated. If the currently active item is the top-most item in the gutter,\n   * then the bottom-most item will be activated. If there is one item in the gutter that is not active, then that item will be activated.\n   */\n  @Method()\n  async activatePrevItem() {\n    const items: HTMLLaGutterItemElement[] = this.layout ? this.layout.sortItems(this.getVisibleItems()) : [];\n\n    if (items.length === 1) {\n      items[0].active = true;\n      return items[0];\n    } else if (items.length > 1) {\n      const activeItemIndex = items.findIndex((item) => item.active);\n      const nextActiveItem =\n        activeItemIndex === -1 || activeItemIndex === 0 ? items[items.length - 1] : items[activeItemIndex - 1];\n      nextActiveItem.active = true;\n      return nextActiveItem;\n    } else {\n      return null;\n    }\n  }\n\n  items(): NodeListOf<HTMLLaGutterItemElement> {\n    return this.el.querySelectorAll('la-gutter-item');\n  }\n\n  getVisibleItems(): HTMLLaGutterItemElement[] {\n    // @ts-ignore\n    return [...this.items()].filter((i) => i.style.display !== 'none');\n  }\n}\n"],"version":3}