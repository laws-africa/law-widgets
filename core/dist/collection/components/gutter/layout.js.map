{"version":3,"file":"layout.js","sourceRoot":"","sources":["../../../src/components/gutter/layout.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Helper class to determine the vertical layout of a collection of gutter content elements, such that they are aligned\n * vertically with their anchor elements, but don't overlap each other.\n */\nexport class GutterLayout {\n  protected root: HTMLElement;\n  protected buffer: number;\n  protected tops: WeakMap<HTMLElement, number>;\n  protected anchors: WeakMap<HTMLElement, HTMLElement>;\n\n  /**\n   * @param root root element for determining heights against. This MUST have a position style attribute,\n   *             such as position: relative;\n   */\n  constructor(root: HTMLElement) {\n    this.root = root;\n    // vertical buffer between elements\n    this.buffer = 10;\n    this.tops = new WeakMap();\n    this.anchors = new WeakMap();\n  }\n\n  layout(items: HTMLLaGutterItemElement[]) {\n    this.updateAnchorsAndItems(items);\n\n    // pre-calculate tops\n    this.updateTops(items);\n\n    // sort items by ascending anchorElement top\n    items = this.sortItems(items);\n\n    // find the first item that is active\n    const activeItem: HTMLLaGutterItemElement | undefined = items.find((x) => x.active);\n\n    if (activeItem) {\n      const ix = items.indexOf(activeItem);\n      if (ix > -1) {\n        // layout the primary item first\n        const anchor: HTMLElement | undefined = this.anchors.get(activeItem);\n        if (anchor) {\n          const top = this.tops.get(anchor);\n          if (top) {\n            activeItem.style.top = `${top}px`;\n            // layout the ones going upwards from here\n            this.layoutUpwards(items, ix - 1, top - this.buffer);\n            // layout the ones going downwards from here\n            this.layoutDownwards(items, ix + 1, top + activeItem.clientHeight + this.buffer);\n            return;\n          }\n        }\n      }\n    }\n\n    // nothing is primary, go top downwards\n    this.layoutDownwards(items, 0, 0);\n  }\n\n  sortItems(items: HTMLLaGutterItemElement[]) {\n    return [...items].sort(this.compareItems.bind(this));\n  }\n\n  /**\n   * Comparator that sorts items be ascending top value.\n   */\n  compareItems(a: HTMLLaGutterItemElement, b: HTMLLaGutterItemElement): number {\n    const anchorA: HTMLElement | undefined = this.anchors.get(a);\n    const anchorB: HTMLElement | undefined = this.anchors.get(b);\n\n    if (anchorA) {\n      if (anchorB) {\n        const topA: number | undefined = this.tops.get(anchorA);\n        const topB: number | undefined = this.tops.get(anchorB);\n\n        if (topA) {\n          if (topB) {\n            return topA - topB;\n          } else {\n            // a has an top, b doesn't, so a comes after b\n            return 1;\n          }\n        } else {\n          // a has no top, best if b comes after a\n          return -1;\n        }\n      } else {\n        // a has an anchor, b doesn't, so a comes after b\n        return 1;\n      }\n    } else {\n      // a has no anchor, best if b comes after a\n      return -1;\n    }\n  }\n\n  layoutUpwards(items: HTMLLaGutterItemElement[], start: number, watermark: number) {\n    // layout the items from index start, going bottom to top\n    for (let i = start; i >= 0; i--) {\n      const item = items[i];\n      const anchor: HTMLElement | undefined = this.anchors.get(item);\n      if (anchor) {\n        let top = this.tops.get(anchor);\n        if (top) {\n          if (top + item.clientHeight >= watermark) {\n            top = watermark - item.clientHeight;\n          }\n          item.style.top = `${top}px`;\n          watermark = top - this.buffer;\n        }\n      }\n    }\n  }\n\n  layoutDownwards(items: HTMLLaGutterItemElement[], start: number, watermark: number) {\n    // layout the items from index start, going top to bottom\n    for (let i = start; i < items.length; i++) {\n      const item = items[i];\n      const anchor: HTMLElement | undefined = this.anchors.get(item);\n      if (anchor) {\n        let top = this.tops.get(anchor);\n        if (top) {\n          top = Math.max(watermark, top);\n          item.style.top = `${top}px`;\n          watermark = top + item.clientHeight + this.buffer;\n        }\n      }\n    }\n  }\n\n  updateAnchorsAndItems(items: HTMLLaGutterItemElement[]) {\n    this.anchors = new WeakMap();\n\n    for (const item of items) {\n      const anchor: HTMLElement | null = this.getItemAnchor(item);\n      if (anchor) {\n        this.anchors.set(item, anchor);\n      }\n      item.style.display = anchor ? '' : 'none';\n    }\n  }\n\n  getItemAnchor(item: HTMLLaGutterItemElement): HTMLElement | null {\n    if (item.anchor) {\n      if (item.anchor instanceof HTMLElement) {\n        return this.root.contains(item.anchor) ? item.anchor : null;\n      } else {\n        return this.root.querySelector(item.anchor);\n      }\n    }\n    return null;\n  }\n\n  updateTops(items: HTMLLaGutterItemElement[]) {\n    this.tops = new WeakMap();\n\n    for (const item of items) {\n      const anchor: HTMLElement | undefined = this.anchors.get(item);\n      if (anchor && !this.tops.has(anchor)) {\n        this.tops.set(anchor, this.calculateTop(anchor));\n      }\n    }\n  }\n\n  /**\n   * Find the top of an element, relative to this.root.\n   * @param element\n   * @returns {number}\n   */\n  calculateTop(element: HTMLElement) {\n    let top = 0;\n    let el: HTMLElement | null = element;\n\n    while (el && el !== this.root) {\n      top += el.offsetTop;\n      el = el.offsetParent as HTMLElement;\n    }\n\n    return top;\n  }\n}\n"]}