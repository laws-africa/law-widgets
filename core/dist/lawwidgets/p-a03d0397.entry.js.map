{"version":3,"names":["GutterLayout","constructor","root","this","buffer","tops","WeakMap","anchors","layout","items","updateAnchorsAndItems","updateTops","sortItems","activeItem","find","x","active","ix","indexOf","anchor","get","top","style","layoutUpwards","layoutDownwards","clientHeight","sort","compareItems","bind","a","b","anchorA","anchorB","topA","topB","start","watermark","i","item","length","Math","max","getItemAnchor","set","display","HTMLElement","contains","querySelector","has","calculateTop","element","el","offsetTop","offsetParent","gutterCss","LaGutterStyle0","Gutter","debounceDelay","componentWillLoad","akomaNtosoElement","getAkomaNtosoElement","akomaNtoso","queueLayout","debounce","layoutItems","mutationObserver","MutationObserver","observe","childList","componentDidLoad","setupLayout","disconnectedCallback","disconnect","resizeObserver","itemChanged","event","target","setOtherItemsInactive","clicked","closest","Array","from","forEach","window","ResizeObserver","layoutComplete","emit","activateNextItem","getVisibleItems","activeItemIndex","findIndex","nextActiveItem","activatePrevItem","querySelectorAll","filter"],"sources":["src/components/gutter/layout.ts","src/components/gutter/gutter.scss?tag=la-gutter","src/components/gutter/gutter.tsx"],"sourcesContent":["/**\n * Helper class to determine the vertical layout of a collection of gutter content elements, such that they are aligned\n * vertically with their anchor elements, but don't overlap each other.\n */\nexport class GutterLayout {\n  protected root: HTMLElement;\n  protected buffer: number;\n  protected tops: WeakMap<HTMLElement, number>;\n  protected anchors: WeakMap<HTMLElement, HTMLElement>;\n\n  /**\n   * @param root root element for determining heights against. This MUST have a position style attribute,\n   *             such as position: relative;\n   */\n  constructor(root: HTMLElement) {\n    this.root = root;\n    // vertical buffer between elements\n    this.buffer = 10;\n    this.tops = new WeakMap();\n    this.anchors = new WeakMap();\n  }\n\n  layout(items: HTMLLaGutterItemElement[]) {\n    this.updateAnchorsAndItems(items);\n\n    // pre-calculate tops\n    this.updateTops(items);\n\n    // sort items by ascending anchorElement top\n    items = this.sortItems(items);\n\n    // find the first item that is active\n    const activeItem: HTMLLaGutterItemElement | undefined = items.find((x) => x.active);\n\n    if (activeItem) {\n      const ix = items.indexOf(activeItem);\n      if (ix > -1) {\n        // layout the primary item first\n        const anchor: HTMLElement | undefined = this.anchors.get(activeItem);\n        if (anchor) {\n          const top = this.tops.get(anchor);\n          if (top) {\n            activeItem.style.top = `${top}px`;\n            // layout the ones going upwards from here\n            this.layoutUpwards(items, ix - 1, top - this.buffer);\n            // layout the ones going downwards from here\n            this.layoutDownwards(items, ix + 1, top + activeItem.clientHeight + this.buffer);\n            return;\n          }\n        }\n      }\n    }\n\n    // nothing is primary, go top downwards\n    this.layoutDownwards(items, 0, 0);\n  }\n\n  sortItems(items: HTMLLaGutterItemElement[]) {\n    return [...items].sort(this.compareItems.bind(this));\n  }\n\n  /**\n   * Comparator that sorts items be ascending top value.\n   */\n  compareItems(a: HTMLLaGutterItemElement, b: HTMLLaGutterItemElement): number {\n    const anchorA: HTMLElement | undefined = this.anchors.get(a);\n    const anchorB: HTMLElement | undefined = this.anchors.get(b);\n\n    if (anchorA) {\n      if (anchorB) {\n        const topA: number | undefined = this.tops.get(anchorA);\n        const topB: number | undefined = this.tops.get(anchorB);\n\n        if (topA) {\n          if (topB) {\n            return topA - topB;\n          } else {\n            // a has an top, b doesn't, so a comes after b\n            return 1;\n          }\n        } else {\n          // a has no top, best if b comes after a\n          return -1;\n        }\n      } else {\n        // a has an anchor, b doesn't, so a comes after b\n        return 1;\n      }\n    } else {\n      // a has no anchor, best if b comes after a\n      return -1;\n    }\n  }\n\n  layoutUpwards(items: HTMLLaGutterItemElement[], start: number, watermark: number) {\n    // layout the items from index start, going bottom to top\n    for (let i = start; i >= 0; i--) {\n      const item = items[i];\n      const anchor: HTMLElement | undefined = this.anchors.get(item);\n      if (anchor) {\n        let top = this.tops.get(anchor);\n        if (top) {\n          if (top + item.clientHeight >= watermark) {\n            top = watermark - item.clientHeight;\n          }\n          item.style.top = `${top}px`;\n          watermark = top - this.buffer;\n        }\n      }\n    }\n  }\n\n  layoutDownwards(items: HTMLLaGutterItemElement[], start: number, watermark: number) {\n    // layout the items from index start, going top to bottom\n    for (let i = start; i < items.length; i++) {\n      const item = items[i];\n      const anchor: HTMLElement | undefined = this.anchors.get(item);\n      if (anchor) {\n        let top = this.tops.get(anchor);\n        if (top) {\n          top = Math.max(watermark, top);\n          item.style.top = `${top}px`;\n          watermark = top + item.clientHeight + this.buffer;\n        }\n      }\n    }\n  }\n\n  updateAnchorsAndItems(items: HTMLLaGutterItemElement[]) {\n    this.anchors = new WeakMap();\n\n    for (const item of items) {\n      const anchor: HTMLElement | null = this.getItemAnchor(item);\n      if (anchor) {\n        this.anchors.set(item, anchor);\n      }\n      item.style.display = anchor ? '' : 'none';\n    }\n  }\n\n  getItemAnchor(item: HTMLLaGutterItemElement): HTMLElement | null {\n    if (item.anchor) {\n      if (item.anchor instanceof HTMLElement) {\n        return this.root.contains(item.anchor) ? item.anchor : null;\n      } else {\n        return this.root.querySelector(item.anchor);\n      }\n    }\n    return null;\n  }\n\n  updateTops(items: HTMLLaGutterItemElement[]) {\n    this.tops = new WeakMap();\n\n    for (const item of items) {\n      const anchor: HTMLElement | undefined = this.anchors.get(item);\n      if (anchor && !this.tops.has(anchor)) {\n        this.tops.set(anchor, this.calculateTop(anchor));\n      }\n    }\n  }\n\n  /**\n   * Find the top of an element, relative to this.root.\n   * @param element\n   * @returns {number}\n   */\n  calculateTop(element: HTMLElement) {\n    let top = 0;\n    let el: HTMLElement | null = element;\n\n    while (el && el !== this.root) {\n      top += el.offsetTop;\n      el = el.offsetParent as HTMLElement;\n    }\n\n    return top;\n  }\n}\n","$la-gutter-padding: 0.5rem;\n\n.la-akoma-ntoso-with-gutter {\n  display: flex;\n  flex-direction: row;\n\n  &> la-akoma-ntoso {\n    flex: 80%;\n    max-width: 80%;\n    position: relative;\n    padding-right: $la-gutter-padding;\n  }\n\n  &> la-gutter {\n    flex: 20%;\n    max-width: 20%;\n    position: relative;\n    overflow-y: hidden;\n\n    background-color: rgba(0, 0, 0, 0.05);\n    padding-left: $la-gutter-padding;\n    padding-right: $la-gutter-padding;\n  }\n}\n\nla-gutter > la-gutter-item {\n  position: absolute;\n  left: 2 * $la-gutter-padding;\n  width: calc(100% - 3 * $la-gutter-padding);\n  transition: top ease-out 100ms, left ease-out 100ms;\n  z-index: 2;\n\n  &[active] {\n    left: $la-gutter-padding;\n    z-index: 3;\n  }\n}\n","import type { EventEmitter } from '@stencil/core';\nimport { Component, Element, Prop, Listen, Method, Event } from '@stencil/core';\nimport debounce from 'lodash/debounce';\n\nimport { getAkomaNtosoElement } from '../../utils/linking';\n\nimport { GutterLayout } from './layout';\n\n@Component({\n  tag: 'la-gutter',\n  styleUrl: 'gutter.scss',\n})\nexport class Gutter {\n  // The akn content element being decorated\n  protected akomaNtosoElement?: HTMLElement | null;\n\n  protected layout?: GutterLayout;\n  protected resizeObserver?: ResizeObserver;\n  protected mutationObserver?: MutationObserver;\n\n  // Delay in msecs to debounce updates\n  protected debounceDelay = 100;\n  protected queueLayout: any;\n\n  /**\n   * CSS selector or HTMLElement for the la-akoma-ntoso element that will be decorated. Defaults\n   * to the containing la-akoma-ntoso element, if any, otherwise the first\n   * `la-akoma-ntoso` element on the page.\n   */\n  // TODO: should  we be watching this? What if it changes?\n  @Prop() akomaNtoso?: string | HTMLElement;\n\n  @Element() el!: HTMLElement;\n\n  componentWillLoad() {\n    // TODO: watch for changes to the akn content?\n    this.akomaNtosoElement = getAkomaNtosoElement(this.el, this.akomaNtoso);\n\n    // setup a debounced function to trigger a layout run.\n    this.queueLayout = debounce(this.layoutItems.bind(this), this.debounceDelay);\n\n    // re-run layout when child elements change\n    this.mutationObserver = new MutationObserver(this.queueLayout);\n    this.mutationObserver.observe(this.el, { childList: true });\n  }\n\n  componentDidLoad() {\n    this.setupLayout();\n    this.layoutItems();\n  }\n\n  disconnectedCallback() {\n    if (this.mutationObserver) {\n      this.mutationObserver.disconnect();\n    }\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n  }\n\n  @Listen('laItemChanged')\n  itemChanged(event: CustomEvent) {\n    const target: HTMLLaGutterItemElement | null = event.target as HTMLLaGutterItemElement;\n    if (target?.active) {\n      // set all other items inactive. if there was a previously active item, this change will\n      // trigger a new event, but the debounce will prevent an unnecessary layout.\n      this.setOtherItemsInactive(target);\n    }\n    this.queueLayout();\n  }\n\n  @Listen('click')\n  clicked(event: MouseEvent) {\n    // a click in the gutter, outside of an item, deactivates all items\n    const target: HTMLElement | null = event.target as HTMLElement;\n    if (target && !target.closest('la-gutter-item')) {\n      Array.from(this.items()).forEach((item) => {\n        item.active = false;\n      });\n    }\n  }\n\n  /**\n   * Event emitted when `this.layout` has finished.\n   */\n  @Event({\n    eventName: 'layoutComplete',\n    composed: true,\n    cancelable: true,\n  })\n  layoutComplete!: EventEmitter<void>;\n\n  /**\n   * Ensure all items except this one are set as inactive.\n   */\n  setOtherItemsInactive(activeItem: HTMLLaGutterItemElement) {\n    Array.from(this.items()).forEach((item) => {\n      if (item != activeItem) {\n        item.active = false;\n      }\n    });\n  }\n\n  setupLayout() {\n    if (this.akomaNtosoElement) {\n      this.layout = new GutterLayout(this.akomaNtosoElement);\n\n      if (window.ResizeObserver) {\n        if (this.resizeObserver) this.resizeObserver.disconnect();\n\n        // add observer to re-layout when the containing document changes size, which implies marker positions will change\n        this.resizeObserver = new ResizeObserver(this.queueLayout);\n        this.resizeObserver.observe(this.akomaNtosoElement);\n      }\n    }\n  }\n\n  /**\n   * Layout the gutter items.\n   */\n  @Method()\n  async layoutItems() {\n    if (this.layout) {\n      // @ts-ignore\n      this.layout.layout([...this.items()]);\n      this.layoutComplete.emit();\n    }\n  }\n\n  /**\n   * Activates the item logically after the currently active item. The activated item's `active` property will be set to\n   * true. Returns the activated item. Or returns null if there are no items. If there is no item currently\n   * active, the top-most item is activated. If the currently active item is the bottom-most item in the gutter,\n   * then the top-most item will be activated. If there is one item in the gutter that is not active, then that item will be activated.\n   */\n  @Method()\n  async activateNextItem() {\n    const items: HTMLLaGutterItemElement[] = this.layout ? this.layout.sortItems(this.getVisibleItems()) : [];\n\n    if (items.length === 1) {\n      items[0].active = true;\n      return items[0];\n    } else if (items.length > 1) {\n      const activeItemIndex = items.findIndex((item) => item.active);\n      const nextActiveItem =\n        activeItemIndex === -1 || activeItemIndex === items.length - 1 ? items[0] : items[activeItemIndex + 1];\n      nextActiveItem.active = true;\n      return nextActiveItem;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Activates the item logically before the currently active item. The activated item's `active` property will be set to\n   * true. Returns the activated item. Or returns null if there are no items. If there is no item currently\n   * active, the bottom-most item is activated. If the currently active item is the top-most item in the gutter,\n   * then the bottom-most item will be activated. If there is one item in the gutter that is not active, then that item will be activated.\n   */\n  @Method()\n  async activatePrevItem() {\n    const items: HTMLLaGutterItemElement[] = this.layout ? this.layout.sortItems(this.getVisibleItems()) : [];\n\n    if (items.length === 1) {\n      items[0].active = true;\n      return items[0];\n    } else if (items.length > 1) {\n      const activeItemIndex = items.findIndex((item) => item.active);\n      const nextActiveItem =\n        activeItemIndex === -1 || activeItemIndex === 0 ? items[items.length - 1] : items[activeItemIndex - 1];\n      nextActiveItem.active = true;\n      return nextActiveItem;\n    } else {\n      return null;\n    }\n  }\n\n  items(): NodeListOf<HTMLLaGutterItemElement> {\n    return this.el.querySelectorAll('la-gutter-item');\n  }\n\n  getVisibleItems(): HTMLLaGutterItemElement[] {\n    // @ts-ignore\n    return [...this.items()].filter((i) => i.style.display !== 'none');\n  }\n}\n"],"mappings":";;;gIAIaA,EAUX,WAAAC,CAAYC,GACVC,KAAKD,KAAOA,EAEZC,KAAKC,OAAS,GACdD,KAAKE,KAAO,IAAIC,QAChBH,KAAKI,QAAU,IAAID,O,CAGrB,MAAAE,CAAOC,GACLN,KAAKO,sBAAsBD,GAG3BN,KAAKQ,WAAWF,GAGhBA,EAAQN,KAAKS,UAAUH,GAGvB,MAAMI,EAAkDJ,EAAMK,MAAMC,GAAMA,EAAEC,SAE5E,GAAIH,EAAY,CACd,MAAMI,EAAKR,EAAMS,QAAQL,GACzB,GAAII,GAAM,EAAG,CAEX,MAAME,EAAkChB,KAAKI,QAAQa,IAAIP,GACzD,GAAIM,EAAQ,CACV,MAAME,EAAMlB,KAAKE,KAAKe,IAAID,GAC1B,GAAIE,EAAK,CACPR,EAAWS,MAAMD,IAAM,GAAGA,MAE1BlB,KAAKoB,cAAcd,EAAOQ,EAAK,EAAGI,EAAMlB,KAAKC,QAE7CD,KAAKqB,gBAAgBf,EAAOQ,EAAK,EAAGI,EAAMR,EAAWY,aAAetB,KAAKC,QACzE,M,IAORD,KAAKqB,gBAAgBf,EAAO,EAAG,E,CAGjC,SAAAG,CAAUH,GACR,MAAO,IAAIA,GAAOiB,KAAKvB,KAAKwB,aAAaC,KAAKzB,M,CAMhD,YAAAwB,CAAaE,EAA4BC,GACvC,MAAMC,EAAmC5B,KAAKI,QAAQa,IAAIS,GAC1D,MAAMG,EAAmC7B,KAAKI,QAAQa,IAAIU,GAE1D,GAAIC,EAAS,CACX,GAAIC,EAAS,CACX,MAAMC,EAA2B9B,KAAKE,KAAKe,IAAIW,GAC/C,MAAMG,EAA2B/B,KAAKE,KAAKe,IAAIY,GAE/C,GAAIC,EAAM,CACR,GAAIC,EAAM,CACR,OAAOD,EAAOC,C,KACT,CAEL,OAAO,C,MAEJ,CAEL,OAAQ,C,MAEL,CAEL,OAAO,C,MAEJ,CAEL,OAAQ,C,EAIZ,aAAAX,CAAcd,EAAkC0B,EAAeC,GAE7D,IAAK,IAAIC,EAAIF,EAAOE,GAAK,EAAGA,IAAK,CAC/B,MAAMC,EAAO7B,EAAM4B,GACnB,MAAMlB,EAAkChB,KAAKI,QAAQa,IAAIkB,GACzD,GAAInB,EAAQ,CACV,IAAIE,EAAMlB,KAAKE,KAAKe,IAAID,GACxB,GAAIE,EAAK,CACP,GAAIA,EAAMiB,EAAKb,cAAgBW,EAAW,CACxCf,EAAMe,EAAYE,EAAKb,Y,CAEzBa,EAAKhB,MAAMD,IAAM,GAAGA,MACpBe,EAAYf,EAAMlB,KAAKC,M,IAM/B,eAAAoB,CAAgBf,EAAkC0B,EAAeC,GAE/D,IAAK,IAAIC,EAAIF,EAAOE,EAAI5B,EAAM8B,OAAQF,IAAK,CACzC,MAAMC,EAAO7B,EAAM4B,GACnB,MAAMlB,EAAkChB,KAAKI,QAAQa,IAAIkB,GACzD,GAAInB,EAAQ,CACV,IAAIE,EAAMlB,KAAKE,KAAKe,IAAID,GACxB,GAAIE,EAAK,CACPA,EAAMmB,KAAKC,IAAIL,EAAWf,GAC1BiB,EAAKhB,MAAMD,IAAM,GAAGA,MACpBe,EAAYf,EAAMiB,EAAKb,aAAetB,KAAKC,M,IAMnD,qBAAAM,CAAsBD,GACpBN,KAAKI,QAAU,IAAID,QAEnB,IAAK,MAAMgC,KAAQ7B,EAAO,CACxB,MAAMU,EAA6BhB,KAAKuC,cAAcJ,GACtD,GAAInB,EAAQ,CACVhB,KAAKI,QAAQoC,IAAIL,EAAMnB,E,CAEzBmB,EAAKhB,MAAMsB,QAAUzB,EAAS,GAAK,M,EAIvC,aAAAuB,CAAcJ,GACZ,GAAIA,EAAKnB,OAAQ,CACf,GAAImB,EAAKnB,kBAAkB0B,YAAa,CACtC,OAAO1C,KAAKD,KAAK4C,SAASR,EAAKnB,QAAUmB,EAAKnB,OAAS,I,KAClD,CACL,OAAOhB,KAAKD,KAAK6C,cAAcT,EAAKnB,O,EAGxC,OAAO,I,CAGT,UAAAR,CAAWF,GACTN,KAAKE,KAAO,IAAIC,QAEhB,IAAK,MAAMgC,KAAQ7B,EAAO,CACxB,MAAMU,EAAkChB,KAAKI,QAAQa,IAAIkB,GACzD,GAAInB,IAAWhB,KAAKE,KAAK2C,IAAI7B,GAAS,CACpChB,KAAKE,KAAKsC,IAAIxB,EAAQhB,KAAK8C,aAAa9B,G,GAU9C,YAAA8B,CAAaC,GACX,IAAI7B,EAAM,EACV,IAAI8B,EAAyBD,EAE7B,MAAOC,GAAMA,IAAOhD,KAAKD,KAAM,CAC7BmB,GAAO8B,EAAGC,UACVD,EAAKA,EAAGE,Y,CAGV,OAAOhC,C,EChLX,MAAMiC,EAAY,0pBAClB,MAAAC,EAAeD,E,MCWFE,EAAM,M,wEASPrD,KAAAsD,cAAgB,I,0BAa1B,iBAAAC,GAEEvD,KAAKwD,kBAAoBC,EAAqBzD,KAAKgD,GAAIhD,KAAK0D,YAG5D1D,KAAK2D,YAAcC,EAAS5D,KAAK6D,YAAYpC,KAAKzB,MAAOA,KAAKsD,eAG9DtD,KAAK8D,iBAAmB,IAAIC,iBAAiB/D,KAAK2D,aAClD3D,KAAK8D,iBAAiBE,QAAQhE,KAAKgD,GAAI,CAAEiB,UAAW,M,CAGtD,gBAAAC,GACElE,KAAKmE,cACLnE,KAAK6D,a,CAGP,oBAAAO,GACE,GAAIpE,KAAK8D,iBAAkB,CACzB9D,KAAK8D,iBAAiBO,Y,CAGxB,GAAIrE,KAAKsE,eAAgB,CACvBtE,KAAKsE,eAAeD,Y,EAKxB,WAAAE,CAAYC,GACV,MAAMC,EAAyCD,EAAMC,OACrD,GAAIA,IAAM,MAANA,SAAM,SAANA,EAAQ5D,OAAQ,CAGlBb,KAAK0E,sBAAsBD,E,CAE7BzE,KAAK2D,a,CAIP,OAAAgB,CAAQH,GAEN,MAAMC,EAA6BD,EAAMC,OACzC,GAAIA,IAAWA,EAAOG,QAAQ,kBAAmB,CAC/CC,MAAMC,KAAK9E,KAAKM,SAASyE,SAAS5C,IAChCA,EAAKtB,OAAS,KAAK,G,EAkBzB,qBAAA6D,CAAsBhE,GACpBmE,MAAMC,KAAK9E,KAAKM,SAASyE,SAAS5C,IAChC,GAAIA,GAAQzB,EAAY,CACtByB,EAAKtB,OAAS,K,KAKpB,WAAAsD,GACE,GAAInE,KAAKwD,kBAAmB,CAC1BxD,KAAKK,OAAS,IAAIR,EAAaG,KAAKwD,mBAEpC,GAAIwB,OAAOC,eAAgB,CACzB,GAAIjF,KAAKsE,eAAgBtE,KAAKsE,eAAeD,aAG7CrE,KAAKsE,eAAiB,IAAIW,eAAejF,KAAK2D,aAC9C3D,KAAKsE,eAAeN,QAAQhE,KAAKwD,kB,GASvC,iBAAMK,GACJ,GAAI7D,KAAKK,OAAQ,CAEfL,KAAKK,OAAOA,OAAO,IAAIL,KAAKM,UAC5BN,KAAKkF,eAAeC,M,EAWxB,sBAAMC,GACJ,MAAM9E,EAAmCN,KAAKK,OAASL,KAAKK,OAAOI,UAAUT,KAAKqF,mBAAqB,GAEvG,GAAI/E,EAAM8B,SAAW,EAAG,CACtB9B,EAAM,GAAGO,OAAS,KAClB,OAAOP,EAAM,E,MACR,GAAIA,EAAM8B,OAAS,EAAG,CAC3B,MAAMkD,EAAkBhF,EAAMiF,WAAWpD,GAASA,EAAKtB,SACvD,MAAM2E,EACJF,KAAqB,GAAKA,IAAoBhF,EAAM8B,OAAS,EAAI9B,EAAM,GAAKA,EAAMgF,EAAkB,GACtGE,EAAe3E,OAAS,KACxB,OAAO2E,C,KACF,CACL,OAAO,I,EAWX,sBAAMC,GACJ,MAAMnF,EAAmCN,KAAKK,OAASL,KAAKK,OAAOI,UAAUT,KAAKqF,mBAAqB,GAEvG,GAAI/E,EAAM8B,SAAW,EAAG,CACtB9B,EAAM,GAAGO,OAAS,KAClB,OAAOP,EAAM,E,MACR,GAAIA,EAAM8B,OAAS,EAAG,CAC3B,MAAMkD,EAAkBhF,EAAMiF,WAAWpD,GAASA,EAAKtB,SACvD,MAAM2E,EACJF,KAAqB,GAAKA,IAAoB,EAAIhF,EAAMA,EAAM8B,OAAS,GAAK9B,EAAMgF,EAAkB,GACtGE,EAAe3E,OAAS,KACxB,OAAO2E,C,KACF,CACL,OAAO,I,EAIX,KAAAlF,GACE,OAAON,KAAKgD,GAAG0C,iBAAiB,iB,CAGlC,eAAAL,GAEE,MAAO,IAAIrF,KAAKM,SAASqF,QAAQzD,GAAMA,EAAEf,MAAMsB,UAAY,Q","ignoreList":[]}